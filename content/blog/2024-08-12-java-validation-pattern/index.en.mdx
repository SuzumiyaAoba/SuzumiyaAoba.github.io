---
title: Bean Validation @Pattern Specification
date: 2024-08-12
category: "Programming"
tags: ["Java", "Programming"]
model: GPT-5.2-Codex
---

## Introduction

This article explains the specification of Java Bean Validation's `@Pattern`.
I keep seeing many explanations that use incorrect examples, and reviewing code that references them is exhausting,
so I decided to stop expecting the world to provide correct information and to publish it myself.

The recent [article](../2024-08-08-java-to-list) is also part of that effort.

## TL;DR

- You do not need to add `^` at the beginning and `$` at the end of the regular expression specified in `@Pattern`'s `regexp`
- Read the docs and confirm the specification
- Do not blindly trust personal blogs, Qiita, or Zenn (self-contradiction)

## Incorrect implementation

If you [search](https://www.google.com/search?q=spring+boot+%E3%83%90%E3%83%AA%E3%83%87%E3%83%BC%E3%82%B7%E3%83%A7%E3%83%B3+%E6%AD%A3%E8%A6%8F%E8%A1%A8%E7%8F%BE) Google for how to apply regex validation with the `@Pattern` annotation in Spring Boot requests, you often see examples like this.

```java
@Value
@Builder
public class Example {

    // !className[/\^/] underline decoration-wavy underline-green-600
    // !className[/\$/] underline decoration-wavy underline-green-600
    @Pattern(regexp = "^[A-Z][a-z]+$")
    String name = "Name";
}
```

You can find examples that use both `^` and `$`, or only one of them, but they write regex for `@Pattern`'s `regexp` in the form `^<regex>$`.
This works and is not incorrect, but you do not need to use `^` and `$`.

People who deliberately add `^` and `$` may not understand the `@Pattern` specification.

## Jakarta Bean Validation

If you want to implement validation in Java, it is common to use a library compliant with [Jakarta Bean Validation](https://beanvalidation.org/).
Jakarta Bean Validation is the specification for Bean Validation, transferred from
[JSR 303](https://www.jcp.org/en/jsr/detail?id=303), [JSR 349](https://www.jcp.org/en/jsr/detail?id=349), and [JSR 380](https://www.jcp.org/en/jsr/detail?id=380),
and managed by the Eclipse Foundation. [^1]

[^1]: For Java EE and Jakarta EE, see [From Java EE to Jakarta EE](https://blogs.oracle.com/otnjp/post/transition-from-java-ee-to-jakarta-ee-ja).

In Java, there are cases where only the specification is defined independently, and multiple libraries implement it.
For example, [Hibernate Validator](https://hibernate.org/validator/) is the reference implementation for Jakarta Bean Validation.
Hibernate Validator is commonly used, but there is also [Apache BVal](https://bval.apache.org/) as a Jakarta Bean Validation-compliant implementation.

## Hibernate Validator

### `PatternValidator`

Validation for the `@Pattern` annotation is performed by `PatternValidator`.

```java
/*
 * Hibernate Validator, declare and validate application constraints
 *
 * License: Apache License, Version 2.0
 * See the license.txt file in the root directory or <http://www.apache.org/licenses/LICENSE-2.0>.
 */
package org.hibernate.validator.internal.constraintvalidators.bv;

import java.lang.invoke.MethodHandles;
import java.util.regex.Matcher;
import java.util.regex.PatternSyntaxException;
import jakarta.validation.ConstraintValidator;
import jakarta.validation.ConstraintValidatorContext;
import jakarta.validation.constraints.Pattern;

import org.hibernate.validator.constraintvalidation.HibernateConstraintValidatorContext;
import org.hibernate.validator.internal.engine.messageinterpolation.util.InterpolationHelper;
import org.hibernate.validator.internal.util.logging.Log;
import org.hibernate.validator.internal.util.logging.LoggerFactory;

/**
 * @author Hardy Ferentschik
 */
public class PatternValidator implements ConstraintValidator<Pattern, CharSequence> {

\tprivate static final Log LOG = LoggerFactory.make(MethodHandles.lookup());

\tprivate java.util.regex.Pattern pattern;
\tprivate String escapedRegexp;

\t@Override
\tpublic void initialize(Pattern parameters) {
\t\tPattern.Flag[] flags = parameters.flags();
\t\tint intFlag = 0;
\t\tfor (Pattern.Flag flag : flags) {
\t\t\tintFlag = intFlag | flag.getValue();
\t\t}

\t\ttry {
\t\t\tpattern = java.util.regex.Pattern.compile(parameters.regexp(), intFlag);
\t\t}
\t\tcatch (PatternSyntaxException e) {
\t\t\tthrow LOG.getInvalidRegularExpressionException(e);
\t\t}

\t\tescapedRegexp = InterpolationHelper.escapeMessageParameter(parameters.regexp());
\t}

\t@Override
\tpublic boolean isValid(CharSequence value, ConstraintValidatorContext constraintValidatorContext) {
\t\tif (value == null) {
\t\t\treturn true;
\t\t}

\t\tif (constraintValidatorContext instanceof HibernateConstraintValidatorContext) {
\t\t\tconstraintValidatorContext.unwrap(HibernateConstraintValidatorContext.class).addMessageParameter("regexp", escapedRegexp);
\t\t}

\t\tMatcher m = pattern.matcher(value);
\t\t// !className[/matches\(\)/] underline decoration-wavy underline-green-600
\t\treturn m.matches();
\t}
}
```

<GitHubCodeLink
  url="https://github.com/hibernate/hibernate-validator/blob/8.0/engine/src/main/java/org/hibernate/validator/internal/constraintvalidators/bv/PatternValidator.java"
  skipPath={4}
/>

Whether validation succeeds is determined by the [`Matcher#matches`](<https://docs.oracle.com/javase/jp/21/docs/api/java.base/java/util/regex/Matcher.html#matches()>) method.
`Matcher#matches` checks whether the **entire string** matches the regular expression.
If only part of the string matches, validation fails.
Therefore, for the `@Pattern` annotation, validation succeeds if the entire string matches the regex even without `^` and `$`.

## Correct (?) implementation

Even though adding `^` and `$` does not change behavior, it is just noise, so it should be avoided.
Thus the earlier example can be rewritten like this.

```java
@Value
@Builder
public class Example {

    @Pattern(regexp = "[A-Z][a-z]+")
    String name = "Name";
}
```

## Conclusion

When specifying a regular expression for `@Pattern`'s `regexp`, you do not need to add `^` and `$`.
Older articles do not use `^$`, but many recent articles seem to add them.

At some point incorrect information was written, and many people likely use code they find online as-is.
Do not blindly trust information found online; it is important to read official documentation and confirm the specification.
