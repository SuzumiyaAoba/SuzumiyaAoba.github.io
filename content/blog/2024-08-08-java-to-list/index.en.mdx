---
title: "The Trap of Stream#toList()"
date: 2024-08-08
tags: ["Java", "Programming"]
category: "Programming"
amazonAssociate: true
amazonProductIds:
  - "Javaによる関数型プログラミング"
---

## Introduction

This article notes the caveats of [`Stream#toList()`](https://docs.oracle.com/javase/jp/16/docs/api/java.base/java/util/stream/Stream.html#toList()).
`Stream#toList()` is a new method introduced in Java 16, and like `Stream#collect(Collectors.toList())`, it converts a `Stream` to a `List`.
However, there is a trap.
Even so, some articles merely say "replace `Stream#collect(Collectors.toList())` with `Stream#toList()`" and stop there.

So I wrote this as a warning.
The problem statement and conclusion overlap with [JDK 16 : stream.toList() に見る API 設計の難しさ - A Memorandum](https://blog1.mammb.com/entry/2021/06/07/000000),
but here I look at more detailed implementations and code with similar behavior.

## **LITERALLY** TL;DL

- [`Stream#collect()`](https://docs.oracle.com/javase/jp/21/docs/api/java.base/java/util/stream/Stream.html#collect(java.util.stream.Collector)) performs [mutable reduction](https://docs.oracle.com/javase/jp/21/docs/api/java.base/java/util/stream/package-summary.html#MutableReduction).
- [`Stream#toList()`](https://docs.oracle.com/javase/jp/21/docs/api/java.base/java/util/stream/Stream.html#toList()) returns an [unmodifiable view](https://docs.oracle.com/javase/jp/21/docs/api/java.base/java/util/Collection.html#unmodview) of a list.
- You should not casually rewrite `Stream#collect(Collectors.toList())` to `Stream#toList()`.
- Read the [Javadoc](https://docs.oracle.com/javase/jp/21/docs/api/index.html).

## Converting `Stream` to `List`

Let's think about code that converts a `Stream` to a `List` in Java.
Here, we compare behavior before and after `Stream#toList()` was added to the JDK.

### Java 8

Since Java 8, you can convert `Stream` to `List` with `Stream#collect(Collectors.toList())`.
Here we use `jshell` to check behavior.

To understand `Stream#collect(Collectors.toList())`, define a utility method `timesN` that takes a `List<Integer>`
and returns a new `List` with each element multiplied by `n`.

```java
jshell> class ListUtils {
   ...>     static List<Integer> timesN(List<Integer> xs, int n) {
   ...>         return xs.stream()
   ...>                  .map(x -> x * n)
   // !className[/.collect\(Collectors.toList\(\)\);/] underline decoration-wavy underline-green-600
   ...>                  .collect(Collectors.toList());
   ...>     }
   ...> }
|  次を作成しました: クラス ListUtils
```

Using this method, you get a list where each element of `List.of(1, 2, 3)` is doubled.

```java
jshell> ListUtils.timesN(List.of(1, 2, 3), 2);
$1 ==> [2, 4, 6]
```

Now try adding an element to the list returned by `timesN`.

```java
jshell> $1.add(8);
$2 ==> true

jshell> $1
$1 ==> [2, 4, 6, 8]
```

You can add elements without issue.
This is because `Collectors.toList()` returns an `ArrayList`.

```java
jshell> $1.getClass();
$3 ==> class java.util.ArrayList
```

However, [the Javadoc](https://docs.oracle.com/javase/jp/21/docs/api/java.base/java/util/stream/Collectors.html#toList()) does not state that it returns an `ArrayList`.
It also says nothing is guaranteed about mutability.
But if you check the **OpenJDK** implementation, you can see it returns `ArrayList`.

```java
public class Collectors {
    // ...

    /**
     * Returns a {@code Collector} that accumulates the input elements into a
     * new {@code List}. There are no guarantees on the type, mutability,
     * serializability, or thread-safety of the {@code List} returned; if more
     * control over the returned {@code List} is required, use {@link #toCollection(Supplier)}.
     *
     * @param <T> the type of the input elements
     * @return a {@code Collector} which collects all the input elements into a
     * {@code List}, in encounter order
     */
    public static <T>
    Collector<T, ?, List<T>> toList() {
        // !className[/ArrayList::new/] underline decoration-wavy underline-green-600
        return new CollectorImpl<>(ArrayList::new, List::add,
                                   (left, right) -> { left.addAll(right); return left; },
                                   CH_ID);
    }

    // ...
}
```

<GitHubCodeLink
  url="https://github.com/openjdk/jdk/blob/jdk-17%2B35/src/java.base/share/classes/java/util/stream/Collectors.java#L268-L283"
  skipPath={1}
/>

OpenJDK returns `ArrayList`, but you should not write code assuming `Collectors.toList()` returns `ArrayList`.
According to the standard Javadoc, the behavior of code like `$1.add(8)` is ***undefined***.
Another JDK might not use `ArrayList`.

In reality, code that adds elements to the result of `Stream#collect(Collectors.toList())` is probably being written.
Many people might think they never do that.
It's true that you rarely call `List#add()` immediately after collecting,
but if you return the `List` from a method (as here), someone could easily call `add()` later.

### Java 16

Now try `Stream#toList()` added in Java 16.
It converts to `List` similarly.

```java
jshell> class ListUtils {
   ...>     static List<Integer> timesN(List<Integer> xs, int n) {
   ...>         return xs.stream()
   ...>                  .map(x -> x * n)
   // !className[/.toList\(\)/] underline decoration-wavy underline-green-600
   ...>                  .toList();
   ...>     }
   ...> }
|  次を作成しました: クラス ListUtils
```

Of course, it returns the doubled list just like `collect(toList())`.

```java
jshell> ListUtils.timesN(List.of(1, 2, 3), 2);
$4 ==> [2, 4, 6]
```

Now try adding an element as before.

```java
jshell> $4.add(8);
|  例外java.lang.UnsupportedOperationException
|        at ImmutableCollections.uoe (ImmutableCollections.java:142)
|        at ImmutableCollections$AbstractImmutableCollection.add (ImmutableCollections.java:147)
|        at (#4:1)
```

Oops :confused:

An exception occurred. Check the class.

```java
jshell> $4.getClass();
$5 ==> class java.util.ImmutableCollections$ListN
```

## **Where did we go wrong?**

Let's stop and re-read the docs for `Stream#collect()` and `Stream#toList()`.

### Docs and implementation

#### `Stream#collect(Collectors.toList())`

Java's `Stream#collect()` performs [mutable reduction](https://docs.oracle.com/javase/jp/21/docs/api/java.base/java/util/stream/package-summary.html#MutableReduction).

> This article is already long, so I will write a separate article about `Stream#collect()` later.

#### `Stream#toList()`

The [Javadoc](https://docs.oracle.com/javase/jp/21/docs/api/java.base/java/util/stream/Stream.html#toList()) says:

> The returned List is unmodifiable. Calls to mutator methods always throw UnsupportedOperationException.

It also says:

> **Implementation Requirements:**
>
> Implementations return a List created as follows:
>
> `Collections.unmodifiableList(new ArrayList<>(Arrays.asList(this.toArray())))`

The point is simple: `Stream#toList()` is **not** a replacement for `Stream#collect(Collectors.toList())`.
`Stream#collect(Collectors.toList())` does not guarantee mutability,
but `Stream#toList()` guarantees immutability via `Collections#unmodifiableList`.

To understand `Stream#toList()`, you need to know:

- `this.toArray()`
- `Arrays#asList`
- `ArrayList` constructor
- `Collections#unmodifiableList`

##### `this.toArray()`

Looking at the source, `Stream#toArray()` is abstract.

```java
    /**
     * Returns an array containing the elements of this stream.
     *
     * <p>This is a <a href="package-summary.html#StreamOps">terminal
     * operation</a>.
     *
     * @return an array, whose {@linkplain Class#getComponentType runtime component
     * type} is {@code Object}, containing the elements of this stream
     */
    Object[] toArray();
```

<GitHubCodeLink
  url="https://github.com/openjdk/jdk/blob/jdk-17%2B35/src/java.base/share/classes/java/util/stream/Stream.java#L872-L881"
  skipPath={1}
/>

So it depends on how the `Stream` implementation is written.
The most common implementation used in classes implementing `List` is probably `ArrayList`.
[`ArrayList`](https://docs.oracle.com/javase/jp/21/docs/api/java.base/java/util/ArrayList.html#toArray()) implements `toArray()` in `AbstractCollection`.

```java
    /**
     * {@inheritDoc}
     *
     * @implSpec
     * This implementation returns an array containing all the elements
     * returned by this collection's iterator, in the same order, stored in
     * consecutive elements of the array, starting with index {@code 0}.
     * The length of the returned array is equal to the number of elements
     * returned by the iterator, even if the size of this collection changes
     * during iteration, as might happen if the collection permits
     * concurrent modification during iteration.  The {@code size} method is
     * called only as an optimization hint; the correct result is returned
     * even if the iterator returns a different number of elements.
     *
     * <p>This method is equivalent to:
     *
     *  <pre> {@code
     * List<E> list = new ArrayList<E>(size());
     * for (E e : this)
     *     list.add(e);
     * return list.toArray();
     * }</pre>
     */
    public Object[] toArray() {
        // Estimate size of array; be prepared to see more or fewer elements
        Object[] r = new Object[size()];
        Iterator<E> it = iterator();
        for (int i = 0; i < r.length; i++) {
            if (! it.hasNext()) // fewer elements than expected
                return Arrays.copyOf(r, i);
            r[i] = it.next();
        }
        return it.hasNext() ? finishToArray(r, it) : r;
    }
```

<GitHubCodeLink
  url="https://github.com/openjdk/jdk/blob/jdk-17%2B35/src/java.base/share/classes/java/util/AbstractCollection.java#L116-L149"
  skipPath={1}
/>

It copies elements into an array using an `Iterator`.
So it scans the list from beginning to end once.

##### `Arrays#asList`

Next, check the implementation of `Arrays#asList`.

```java
    /**
     * Returns a fixed-size list backed by the specified array. Changes made to
     * the array will be visible in the returned list, and changes made to the
     * list will be visible in the array. The returned list is
     * {@link Serializable} and implements {@link RandomAccess}.
     *
     * <p>The returned list implements the optional {@code Collection} methods, except
     * those that would change the size of the returned list. Those methods leave
     * the list unchanged and throw {@link UnsupportedOperationException}.
     *
     * @apiNote
     * This method acts as bridge between array-based and collection-based
     * APIs, in combination with {@link Collection#toArray}.
     *
     * <p>This method provides a way to wrap an existing array:
     * <pre>{@code
     *     Integer[] numbers = ...
     *     ...
     *     List<Integer> values = Arrays.asList(numbers);
     * }</pre>
     *
     * <p>This method also provides a convenient way to create a fixed-size
     * list initialized to contain several elements:
     * <pre>{@code
     *     List<String> stooges = Arrays.asList("Larry", "Moe", "Curly");
     * }</pre>
     *
     * <p><em>The list returned by this method is modifiable.</em>
     * To create an unmodifiable list, use
     * {@link Collections#unmodifiableList Collections.unmodifiableList}
     * or <a href="List.html#unmodifiable">Unmodifiable Lists</a>.
     *
     * @param <T> the class of the objects in the array
     * @param a the array by which the list will be backed
     * @return a list view of the specified array
     * @throws NullPointerException if the specified array is {@code null}
     */
    @SafeVarargs
    @SuppressWarnings("varargs")
    public static <T> List<T> asList(T... a) {
        // !className[/ArrayList/] underline decoration-wavy underline-green-600
        return new ArrayList<>(a);
    }
```

<GitHubCodeLink
  url="https://github.com/openjdk/jdk/blob/jdk-17%2B35/src/java.base/share/classes/java/util/Arrays.java#L4082-L4123"
  skipPath={1}
/>

The `ArrayList` here is not `java.util.ArrayList`, but `Arrays.ArrayList`, an inner class of `Arrays`.

```java
    /**
     * @serial include
     */
    // !className[/AbstractList/] underline decoration-wavy underline-green-600
    private static class ArrayList<E> extends AbstractList<E>
        implements RandomAccess, java.io.Serializable
    {
        @java.io.Serial
        private static final long serialVersionUID = -2764017481108945198L;
        @SuppressWarnings("serial") // Conditionally serializable
        // !className[/private final E.. a/] underline decoration-wavy underline-green-600
        private final E[] a;

        ArrayList(E[] array) {
            // !className[/a = Objects.requireNonNull\(array\);/] underline decoration-wavy underline-green-600
            a = Objects.requireNonNull(array);
        }
```

<GitHubCodeLink
  url="https://github.com/openjdk/jdk/blob/jdk-17+35/src/java.base/share/classes/java/util/Arrays.java#L4125-L4138"
  skipPath={1}
/>

The constructor just keeps the passed array after a null check.
Mutable operations like `add` are not implemented in this `ArrayList`, but in its parent `AbstractList`.

```java
    /**
     * {@inheritDoc}
     *
     * @implSpec
     * This implementation always throws an
     * {@code UnsupportedOperationException}.
     *
     * @throws UnsupportedOperationException {@inheritDoc}
     * @throws ClassCastException            {@inheritDoc}
     * @throws NullPointerException          {@inheritDoc}
     * @throws IllegalArgumentException      {@inheritDoc}
     * @throws IndexOutOfBoundsException     {@inheritDoc}
     */
    public void add(int index, E element) {
        throw new UnsupportedOperationException();
    }
```

<GitHubCodeLink
  url="https://github.com/openjdk/jdk/blob/jdk-17%2B35/src/java.base/share/classes/java/util/AbstractList.java#L139-L154"
  skipPath={1}
/>

As you can see, it always throws `UnsupportedOperationException`, so `Arrays#asList(...)` returns an unmodifiable list.

##### `ArrayList` constructor

`ArrayList`'s constructor is implemented as follows.

```java
    /**
     * Constructs a list containing the elements of the specified
     * collection, in the order they are returned by the collection's
     * iterator.
     *
     * @param c the collection whose elements are to be placed into this list
     * @throws NullPointerException if the specified collection is null
     */
    // !className[/Collection<? extends E> c/] underline decoration-wavy underline-green-600
    public ArrayList(Collection<? extends E> c) {
        Object[] a = c.toArray();
        if ((size = a.length) != 0) {
            if (c.getClass() == ArrayList.class) {
                elementData = a;
            } else {
                // !className[/elementData = Arrays.copyOf\(a, size, Object...class\);/] underline decoration-wavy underline-green-600
                elementData = Arrays.copyOf(a, size, Object[].class);
            }
        } else {
            // replace with empty array.
            elementData = EMPTY_ELEMENTDATA;
        }
    }
```

<GitHubCodeLink
  url="https://github.com/openjdk/jdk/blob/jdk-17%2B35/src/java.base/share/classes/java/util/ArrayList.java#L172-L192"
  skipPath={1}
/>

It takes any collection and converts it to an array with `Collection#toArray()`.
If the collection is `java.util.ArrayList`, it keeps the array as-is;
otherwise it copies it with `Arrays#copyOf`.

In our case, the constructor receives `java.util.Arrays$ArrayList` (not `java.util.ArrayList`),
so the array is copied via `Arrays#copyOf`.

Before checking `Arrays#copyOf`, let's see how `toArray` is implemented in the `ArrayList` returned by `Arrays#asList()`.

```java
        @Override
        public Object[] toArray() {
            return Arrays.copyOf(a, a.length, Object[].class);
        }
```

<GitHubCodeLink
  url="https://github.com/openjdk/jdk/blob/jdk-17%2B35/src/java.base/share/classes/java/util/Arrays.java#L4145-L4148"
  skipPath={1}
/>

Inside `Arrays#asList`, `Arrays#copyOf` is already called.
Surprisingly, in this flow, `ArrayList`'s constructor calls `Arrays#copyOf` **twice**.
Maybe I'm missing something.
This double copy only happens for `ArrayList`; for other data structures, `this.toArray()` might behave differently.

Now let's check `Arrays#copyOf`.

```java
    /**
     * Copies the specified array, truncating or padding with nulls (if necessary)
     * so the copy has the specified length.  For all indices that are
     * valid in both the original array and the copy, the two arrays will
     * contain identical values.  For any indices that are valid in the
     * copy but not the original, the copy will contain {@code null}.
     * Such indices will exist if and only if the specified length
     * is greater than that of the original array.
     * The resulting array is of the class {@code newType}.
     *
     * @param <U> the class of the objects in the original array
     * @param <T> the class of the objects in the returned array
     * @param original the array to be copied
     * @param newLength the length of the copy to be returned
     * @param newType the class of the copy to be returned
     * @return a copy of the original array, truncated or padded with nulls
     *     to obtain the specified length
     * @throws NegativeArraySizeException if {@code newLength} is negative
     * @throws NullPointerException if {@code original} is null
     * @throws ArrayStoreException if an element copied from
     *     {@code original} is not of a runtime type that can be stored in
     *     an array of class {@code newType}
     * @since 1.6
     */
    @IntrinsicCandidate
    public static <T,U> T[] copyOf(U[] original, int newLength, Class<? extends T[]> newType) {
        @SuppressWarnings("unchecked")
        T[] copy = ((Object)newType == (Object)Object[].class)
            ? (T[]) new Object[newLength]
            : (T[]) Array.newInstance(newType.getComponentType(), newLength);
        // !className[/System.arraycopy/] underline decoration-wavy underline-green-600
        System.arraycopy(original, 0, copy, 0,
                         Math.min(original.length, newLength));
        return copy;
    }
```

<GitHubCodeLink
  url="https://github.com/openjdk/jdk/blob/jdk-17%2B35/src/java.base/share/classes/java/util/Arrays.java#L3484-L3517"
  skipPath={1}
/>

It allocates a same-size array and copies it.
This is as far as we can follow in Java.
It uses [`System.arraycopy`](https://github.com/openjdk/jdk/blob/jdk-17%2B35/src/java.base/share/classes/java/lang/System.java#L553-L648),
which is a JVM native method, not Java code.

So in `ArrayList`'s constructor, if the collection stores data in an array, it copies it efficiently.

##### `Collections#unmodifiableList()`

Finally, let's check `Collections#unmodifiableList()`.

```java
    /**
     * Returns an <a href="Collection.html#unmodview">unmodifiable view</a> of the
     * specified list. Query operations on the returned list "read through" to the
     * specified list, and attempts to modify the returned list, whether
     * direct or via its iterator, result in an
     * {@code UnsupportedOperationException}.<p>
     *
     * The returned list will be serializable if the specified list
     * is serializable. Similarly, the returned list will implement
     * {@link RandomAccess} if the specified list does.
     *
     * @implNote This method may return its argument if the argument is already unmodifiable.
     * @param  <T> the class of the objects in the list
     * @param  list the list for which an unmodifiable view is to be returned.
     * @return an unmodifiable view of the specified list.
     */
    @SuppressWarnings("unchecked")
    public static <T> List<T> unmodifiableList(List<? extends T> list) {
        if (list.getClass() == UnmodifiableList.class || list.getClass() == UnmodifiableRandomAccessList.class) {
           return (List<T>) list;
        }

        return (list instanceof RandomAccess ?
                // !className[/new UnmodifiableRandomAccessList<>(list)/] underline decoration-wavy underline-green-600
                new UnmodifiableRandomAccessList<>(list) :
                new UnmodifiableList<>(list));
    }
```

<GitHubCodeLink
  url="https://github.com/openjdk/jdk/blob/jdk-17%2B35/src/java.base/share/classes/java/util/Collections.java#L1301-L1326"
  skipPath={1}
/>

Since `Collections#unmodifiableList()` receives a `java.util.ArrayList` instance,
it returns `new UnmodifiableRandomAccessList<>(list)`.

Most of `UnmodifiableRandomAccessList` is implemented in `UnmodifiableList`.

```java
    /**
     * @serial include
     */
    // !className[/extends UnmodifiableList<E>/] underline decoration-wavy underline-green-600
    static class UnmodifiableRandomAccessList<E> extends UnmodifiableList<E>
                                              implements RandomAccess
    {
        UnmodifiableRandomAccessList(List<? extends E> list) {
            super(list);
        }

        public List<E> subList(int fromIndex, int toIndex) {
            return new UnmodifiableRandomAccessList<>(
                list.subList(fromIndex, toIndex));
        }

        @java.io.Serial
        private static final long serialVersionUID = -2542308836966382001L;

        /**
         * Allows instances to be deserialized in pre-1.4 JREs (which do
         * not have UnmodifiableRandomAccessList).  UnmodifiableList has
         * a readResolve method that inverts this transformation upon
         * deserialization.
         */
        @java.io.Serial
        private Object writeReplace() {
            return new UnmodifiableList<>(list);
        }
    }
```

<GitHubCodeLink
  url="https://github.com/openjdk/jdk/blob/jdk-17%2B35/src/java.base/share/classes/java/util/Collections.java#L1427-L1455"
  skipPath={1}
/>

`UnmodifiableList` wraps the provided list and throws `UnsupportedOperationException` for mutating operations.

```java
    /**
     * @serial include
     */
    static class UnmodifiableList<E> extends UnmodifiableCollection<E>
                                  implements List<E> {
        @java.io.Serial
        private static final long serialVersionUID = -283967356065247728L;

        @SuppressWarnings("serial") // Conditionally serializable
        final List<? extends E> list;

        UnmodifiableList(List<? extends E> list) {
            super(list);
            this.list = list;
        }

        public boolean equals(Object o) {return o == this || list.equals(o);}
        public int hashCode()           {return list.hashCode();}

        public E get(int index) {return list.get(index);}
        public E set(int index, E element) {
            // !className[/UnsupportedOperationException/] underline decoration-wavy underline-green-600
            throw new UnsupportedOperationException();
        }
        public void add(int index, E element) {
            // !className[/UnsupportedOperationException/] underline decoration-wavy underline-green-600
            throw new UnsupportedOperationException();
        }
        // ...
```

<GitHubCodeLink
  url="https://github.com/openjdk/jdk/blob/jdk-17%2B35/src/java.base/share/classes/java/util/Collections.java#L1328-L1353"
  skipPath={1}
/>

`Collections#unmodifiableList()` wraps the original list without copying data.
Therefore, in `Stream#toList()`, if the source collection is `ArrayList`,
**there is no scan from head to tail—only two array copies**.

#### `Collectors#toUnmodifiableList()`

If you've looked at `Stream` methods since Java 11, you might think:
"There is `Collectors#toUnmodifiableList()`. So isn't `Stream#toList()` a replacement for `Stream#collect(Collectors.toUnmodifiableList())`?"

Let's look at the implementation.

```java
public class Collectors {
    // ...

    /**
     * Returns a {@code Collector} that accumulates the input elements into an
     * <a href="../List.html#unmodifiable">unmodifiable List</a> in encounter
     * order. The returned Collector disallows null values and will throw
     * {@code NullPointerException} if it is presented with a null value.
     *
     * @param <T> the type of the input elements
     * @return a {@code Collector} that accumulates the input elements into an
     * <a href="../List.html#unmodifiable">unmodifiable List</a> in encounter order
     * @since 10
     */
    public static <T>
    Collector<T, ?, List<T>> toUnmodifiableList() {
        return new CollectorImpl<>(ArrayList::new, List::add,
                                   (left, right) -> { left.addAll(right); return left; },
                                   list -> {
                                       if (list.getClass() == ArrayList.class) { // ensure it's trusted
                                           return SharedSecrets.getJavaUtilCollectionAccess()
                                                               .listFromTrustedArray(list.toArray());
                                       } else {
                                           throw new IllegalArgumentException();
                                       }
                                   },
                                   CH_NOID);
    }
}
```

<GitHubCodeLink
  url="https://github.com/openjdk/jdk/blob/jdk-17%2B35/src/java.base/share/classes/java/util/stream/Collectors.java#L285-L309"
  skipPath={1}
/>

Going into `Collector` behavior would make this even longer, so I won't explain `CollectorImpl` in detail.
This `CollectorImpl` accumulates elements into an `ArrayList`, merges lists, and finally converts to an unmodifiable list via `listFromTrustedArray`.

The interesting part is `SharedSecrets`. Let's look at it.

```java
/** A repository of "shared secrets", which are a mechanism for
    calling implementation-private methods in another package without
    using reflection. A package-private class implements a public
    interface and provides the ability to call package-private methods
    within that package; the object implementing that interface is
    provided through a third package to which access is restricted.
    This framework avoids the primary disadvantage of using reflection
    for this purpose, namely the loss of compile-time checking. */

public class SharedSecrets {
    // ...

    public static JavaUtilCollectionAccess getJavaUtilCollectionAccess() {
        var access = javaUtilCollectionAccess;
        if (access == null) {
            try {
                // !className[/ImmutableCollections$Access/] underline decoration-wavy underline-green-600
                Class.forName("java.util.ImmutableCollections$Access", true, null);
                access = javaUtilCollectionAccess;
            } catch (ClassNotFoundException e) {}
        }
        return access;
    }

    // ...
}
```

<GitHubCodeLink
  url="https://github.com/openjdk/jdk/blob/jdk-17%2B35/src/java.base/share/classes/jdk/internal/access/SharedSecrets.java#L89-L98"
  skipPath={1}
/>

Why is it written this way? The Javadoc explains it, and so does this [StackOverflow answer](https://stackoverflow.com/questions/46722452/how-does-the-sharedsecrets-mechanism-work), which also touches on JPMS introduced in Java 9.

Here `java.util.ImmutableCollections$Access` provides a `JavaUtilCollectionAccess` implementation, so let's check that.

```java
    static class Access {
        static {
            SharedSecrets.setJavaUtilCollectionAccess(new JavaUtilCollectionAccess() {
                public <E> List<E> listFromTrustedArray(Object[] array) {
                    return ImmutableCollections.listFromTrustedArray(array);
                }
                public <E> List<E> listFromTrustedArrayNullsAllowed(Object[] array) {
                    return ImmutableCollections.listFromTrustedArrayNullsAllowed(array);
                }
            });
        }
    }
```

<GitHubCodeLink
  url="https://github.com/openjdk/jdk/blob/jdk-17%2B35/src/java.base/share/classes/java/util/ImmutableCollections.java#L120-L131"
  skipPath={1}
/>

It converts an array to an unmodifiable list via `ImmutableCollections#listFromTrustedArray`.
The implementation is below, and **it explicitly checks for `null` on each element before conversion**.
So it **scans the list from beginning to end once**.

```java
    /**
     * Creates a new List from a trusted array, checking for and rejecting null
     * elements.
     *
     * <p>A trusted array has no references retained by the caller. It can therefore be
     * safely reused as the List's internal storage, avoiding a defensive copy. The array's
     * class must be Object[].class. This method is declared with a parameter type of
     * Object... instead of E... so that a varargs call doesn't accidentally create an array
     * of some class other than Object[].class.
     *
     * @param <E> the List's element type
     * @param input the input array
     * @return the new list
     */
    @SuppressWarnings("unchecked")
    static <E> List<E> listFromTrustedArray(Object... input) {
        assert input.getClass() == Object[].class;
        for (Object o : input) { // implicit null check of 'input' array
            Objects.requireNonNull(o);
        }

        return switch (input.length) {
            case 0  -> (List<E>) ImmutableCollections.EMPTY_LIST;
            case 1  -> (List<E>) new List12<>(input[0]);
            case 2  -> (List<E>) new List12<>(input[0], input[1]);
            default -> (List<E>) new ListN<>(input, false);
        };
    }
```

<GitHubCodeLink
  url="https://github.com/openjdk/jdk/blob/jdk-17%2B35/src/java.base/share/classes/java/util/ImmutableCollections.java#L195-L222"
  skipPath={1}
/>

From this code, the list returned by `Collectors#toUnmodifiableList()` is one of:

- `ImmutableCollections.EMPTY_LIST`
- `List12`
- `ListN`

Their [implementations](https://github.com/openjdk/jdk/blob/jdk-17%2B35/src/java.base/share/classes/java/util/ImmutableCollections.java#L249-L740) are similar to `UnmodifiableList`, so I skip them here.

### Differences between `Stream#collect(Collectors.toList())` and `Stream#toList()`

`Stream#collect(Collectors.toList())` and `Stream#toList()` both return unmodifiable lists.
They look the same, but if you followed the implementation, you should see two clear differences.

#### When elements include `null`

**`Stream#collect(Collectors.toUnmodifiableList())` and `Stream#toList()` behave differently when elements contain `null`.**

Let's check in jshell.

```java
jshell> Stream.of(1, null, 3).toList();
$1 ==> [1, null, 3]

jshell> Stream.of(1, null, 3).collect(Collectors.toUnmodifiableList());
|  例外java.lang.NullPointerException
|        at Objects.requireNonNull (Objects.java:209)
|        at ImmutableCollections.listFromTrustedArray (ImmutableCollections.java:213)
|        at ImmutableCollections$Access$1.listFromTrustedArray (ImmutableCollections.java:124)
|        at Collectors.lambda$toUnmodifiableList$6 (Collectors.java:303)
|        at ReferencePipeline.collect (ReferencePipeline.java:686)
|        at (#13:1)
```

`Stream#toList()` allows `null`, but `Stream#collect(Collectors.toUnmodifiableList())` throws when `null` is present.
That's a big difference.

#### Runtime overhead

As mentioned, `Stream#collect(Collectors.toUnmodifiableList())` first scans the list to accumulate into an array,
then scans again to perform explicit `null` checks.
So it scans the list twice, causing more overhead.

`Collectors.toList()` also scans once to fill an `ArrayList`,
but since it doesn't do `null` checks, it scans once.

`Stream#toList()` copies the array twice, but does not refill an `ArrayList`; it just wraps it with `Collections.unmodifiableList()`.
So in code, it looks much faster than the other two.

- [java - Would Stream.toList() perform better than Collectors.toList() - Stack Overflow](https://stackoverflow.com/questions/65741773/would-stream-tolist-perform-better-than-collectors-tolist)

#### Summary of implementations

Summarizing the findings:

| Expression                                         | Mutability      |  Null   | Efficiency |
| -------------------------------------------------- | :-------------: | :-----: | :--------: |
| `Stream#collect(Collectors.toList())`              | :-1: Mutable    | :+1: OK | :-1: Bad   |
| `Stream#collect(Collectors.toUnmodifiableList())`  | :+1: Immutable  | :-1: NG | :-1: Worst |
| `Stream#toList()`                                  | :+1: Immutable  | :+1: OK | :+1: Best  |

I did not know this relationship before writing the article.

> Everyone is different and everyone is good.
>
> <cite>Misuzu Kaneko</cite>

### Naming is important

The core problem is lack of naming consistency.
Traditionally in Java, `List` typically meant a mutable list [citation needed].
Indeed, `Collectors#toList()` returns a mutable list.
And for unmodifiable collections, methods were named with the _unmodifiable-_ prefix, like `Collectors#toUnmodifiableList()`.

So perhaps `Stream#toList()` should have been named `Stream#toUnmodifiableList()`.
I haven't traced why `Stream#toList()` was added, but the person who chose the name bears a heavy sin (personal opinion).

### A half-baked implementation

Who is happy about collections being mutable across method/class boundaries today?
Mutability makes code harder to follow and causes bugs.

To meet that need, Java 10 added [`Collectors#toUnmodifiableList()`](https://docs.oracle.com/javase/jp/21/docs/api/java.base/java/util/stream/Collectors.html#toUnmodifiableList()).
It returns an [unmodifiable List](https://docs.oracle.com/javase/jp/21/docs/api/java.base/java/util/List.html#unmodifiable).

But looking at its implementation, `Collectors#toUnmodifiableList()` is clearly slower than the other two methods,
so it is hard to recommend.

### Lesson

This shows the difficulty of API design.
Not only standard library API design, but also API design in code that uses the standard library.
We should not expose more information than necessary, and we should avoid APIs that require users to know internal details.
In a standard library, you would think you could be less careful, but with Java collections, **the burden falls on users**.

Therefore, **when changing collection-related code, you must pay attention not just to the interface but the concrete instance**.

## Conclusion

This article was about `Stream#toList()`'s caveats, but it is more accurate to say it is about `Stream#collect(Collectors.toList())`
and the issues in the Java standard library. I didn't expect it to become such a long journey.

In general, programmers must understand data structures and choose appropriately, but today many people code without learning API design or data structures.
And not only beginners, but even experienced developers often do not read official docs before using classes and methods.
For this issue, the naming and API design of the Java standard library seem responsible.

This may not be unique to Java, but in my (limited) experience, Java collections are hard.
The [Java practice of throwing runtime exceptions for invalid operations](https://docs.oracle.com/javase/jp/21/docs/api/java.base/java/util/Collection.html#Collection.15X1lc) makes it worse.

This mutability Q&A is described in the [Collections Framework FAQ](https://docs.oracle.com/javase/jp/8/docs/technotes/guides/collections/index.html).

- [Why not directly support immutability in core collection interfaces to eliminate optional operations (and UnsupportedOperationException)?](https://docs.oracle.com/javase/jp/8/docs/technotes/guides/collections/designfaq.html#a1)

It is long, but I still think it might have been better to separate APIs by mutability.
Fighting collections where mutability is unknown until you call a method is painful.
Half-baked immutability leads to traps like `Stream#toList()`.
At that point, you might think: why not just always use mutable collections?
This case shows that in Java, immutable collections give almost no static-analysis benefit.

Languages like Scala center on immutable collections,
but it seems hard for a language built around mutable collections like Java to transition.

I look forward to the day Java collections are rebuilt.

At least after reading this article, you won't be so afraid of `Stream#toList()` that you can only sleep at night.
Please nap peacefully.

If you feel relieved, I'd be happy if you react with :+1: in Giscus.

## References

- [JDK 16 : stream.toList() に見る API 設計の難しさ - A Memorandum](https://blog1.mammb.com/entry/2021/06/07/000000)
